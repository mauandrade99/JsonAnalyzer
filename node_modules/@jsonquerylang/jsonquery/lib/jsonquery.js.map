{"version":3,"file":"jsonquery.js","sources":["../src/is.ts","../src/functions.ts","../src/compile.ts","../src/operators.ts","../src/regexps.ts","../src/parse.ts","../src/stringify.ts","../src/jsonquery.ts"],"sourcesContent":["export const isArray = <T>(value: unknown): value is T[] => Array.isArray(value)\n\nexport const isObject = (value: unknown): value is object =>\n  value !== null && typeof value === 'object' && !isArray(value)\n\nexport const isString = (value: unknown): value is string => typeof value === 'string'\n\n// source: https://stackoverflow.com/a/77278013/1262753\nexport const isEqual = <T>(a: T, b: T): boolean => {\n  if (a === b) {\n    return true\n  }\n\n  const bothObject = a !== null && b !== null && typeof a === 'object' && typeof b === 'object'\n\n  return (\n    bothObject &&\n    Object.keys(a).length === Object.keys(b).length &&\n    Object.entries(a).every(([k, v]) => isEqual(v, b[k as keyof T]))\n  )\n}\n","import { compile } from './compile'\nimport { isArray, isEqual } from './is'\nimport type {\n  Entry,\n  FunctionBuilder,\n  FunctionBuildersMap,\n  Getter,\n  JSONPath,\n  JSONQuery,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryProperty\n} from './types'\n\nexport function buildFunction(fn: (...args: unknown[]) => unknown): FunctionBuilder {\n  return (...args: JSONQuery[]) => {\n    const compiledArgs = args.map((arg) => compile(arg))\n\n    const arg0 = compiledArgs[0]\n    const arg1 = compiledArgs[1]\n\n    return compiledArgs.length === 1\n      ? (data: unknown) => fn(arg0(data))\n      : compiledArgs.length === 2\n        ? (data: unknown) => fn(arg0(data), arg1(data))\n        : (data: unknown) => fn(...compiledArgs.map((arg) => arg(data)))\n  }\n}\n\nconst sortableTypes = { boolean: 0, number: 1, string: 2 }\nconst otherTypes = 3\n\nconst gt = (a: unknown, b: unknown) =>\n  typeof a === typeof b && (typeof a) in sortableTypes ? a > b : false\n\nconst gte = (a: unknown, b: unknown) => isEqual(a, b) || gt(a, b)\n\nconst lt = (a: unknown, b: unknown) =>\n  typeof a === typeof b && (typeof a) in sortableTypes ? a < b : false\n\nconst lte = (a: unknown, b: unknown) => isEqual(a, b) || lt(a, b)\n\nexport const functions: FunctionBuildersMap = {\n  pipe: (...entries: JSONQuery[]) => {\n    const _entries = entries.map((entry) => compile(entry))\n\n    return (data: unknown) => _entries.reduce((data, evaluator) => evaluator(data), data)\n  },\n\n  object: (query: JSONQueryObject) => {\n    const getters: Getter[] = Object.keys(query).map((key) => [key, compile(query[key])])\n\n    return (data: unknown) => {\n      const obj = {}\n      for (const [key, getter] of getters) {\n        obj[key] = getter(data)\n      }\n      return obj\n    }\n  },\n\n  array: (...items: JSONQuery[]) => {\n    const _items = items.map((entry: JSONQuery) => compile(entry))\n\n    return (data: unknown) => _items.map((item) => item(data))\n  },\n\n  get: (...path: JSONPath) => {\n    if (path.length === 0) {\n      return (data: unknown) => data ?? null\n    }\n\n    if (path.length === 1) {\n      const prop = path[0]\n      return (data: unknown) => data?.[prop] ?? null\n    }\n\n    return (data: unknown) => {\n      let value = data\n\n      for (const prop of path) {\n        value = value?.[prop]\n      }\n\n      return value ?? null\n    }\n  },\n\n  map: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: T[]) => data.map(_callback)\n  },\n\n  mapObject: <T, U>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        const updated = _callback({ key, value: data[key] }) as Entry<U>\n        output[updated.key] = updated.value\n      }\n      return output\n    }\n  },\n\n  mapKeys: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        const updatedKey = _callback(key) as string\n        output[updatedKey] = data[key]\n      }\n      return output\n    }\n  },\n\n  mapValues: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        output[key] = _callback(data[key])\n      }\n      return output\n    }\n  },\n\n  filter: <T>(predicate: JSONQuery) => {\n    const _predicate = compile(predicate)\n\n    return (data: T[]) => data.filter((item) => truthy(_predicate(item)))\n  },\n\n  sort: <T>(path: JSONQueryProperty = ['get'], direction?: 'asc' | 'desc') => {\n    const getter = compile(path)\n    const sign = direction === 'desc' ? -1 : 1\n\n    function compare(itemA: unknown, itemB: unknown) {\n      const a = getter(itemA)\n      const b = getter(itemB)\n\n      // Order mixed types\n      if (typeof a !== typeof b) {\n        const aIndex = sortableTypes[typeof a] ?? otherTypes\n        const bIndex = sortableTypes[typeof b] ?? otherTypes\n\n        return aIndex > bIndex ? sign : aIndex < bIndex ? -sign : 0\n      }\n\n      // Order two numbers, two strings, or two booleans\n      if ((typeof a) in sortableTypes) {\n        return a > b ? sign : a < b ? -sign : 0\n      }\n\n      // Leave arrays, objects, and unknown types ordered as is\n      return 0\n    }\n\n    return (data: T[]) => data.slice().sort(compare)\n  },\n\n  reverse:\n    <T>() =>\n    (data: T[]) =>\n      data.toReversed(),\n\n  pick: (...properties: JSONQueryProperty[]) => {\n    const getters = properties.map(\n      ([_get, ...path]) => [path[path.length - 1], functions.get(...path)] as Getter\n    )\n\n    const _pick = (object: Record<string, unknown>, getters: Getter[]): unknown => {\n      const out = {}\n      for (const [key, getter] of getters) {\n        out[key] = getter(object)\n      }\n      return out\n    }\n\n    return (data: Record<string, unknown>): unknown => {\n      if (isArray(data)) {\n        return data.map((item: Record<string, unknown>) => _pick(item, getters))\n      }\n\n      return _pick(data, getters)\n    }\n  },\n\n  groupBy: <T>(path: JSONQueryProperty) => {\n    const getter = compile(path)\n\n    return (data: T[]) => {\n      const res = {}\n\n      for (const item of data) {\n        const value = getter(item) as string\n        if (res[value]) {\n          res[value].push(item)\n        } else {\n          res[value] = [item]\n        }\n      }\n\n      return res\n    }\n  },\n\n  keyBy: <T>(path: JSONQueryProperty) => {\n    const getter = compile(path)\n\n    return (data: T[]) => {\n      const res = {}\n\n      for (const item of data) {\n        const value = getter(item) as string\n        if (!(value in res)) {\n          res[value] = item\n        }\n      }\n\n      return res\n    }\n  },\n\n  flatten: () => (data: unknown[]) => data.flat(),\n\n  join:\n    <T>(separator = '') =>\n    (data: T[]) =>\n      data.join(separator),\n\n  split: buildFunction((text: string, separator?: string) =>\n    separator !== undefined ? text.split(separator) : text.trim().split(/\\s+/)\n  ),\n\n  substring: buildFunction((text: string, start: number, end?: number) =>\n    text.slice(Math.max(start, 0), end)\n  ),\n\n  uniq:\n    () =>\n    <T>(data: T[]) => {\n      const res: T[] = []\n\n      for (const item of data) {\n        if (res.findIndex((resItem) => isEqual(resItem, item)) === -1) {\n          res.push(item)\n        }\n      }\n\n      return res\n    },\n\n  uniqBy:\n    <T>(path: JSONQueryProperty) =>\n    (data: T[]): T[] =>\n      Object.values(functions.keyBy(path)(data)),\n\n  limit:\n    (count: number) =>\n    <T>(data: T[]) =>\n      data.slice(0, Math.max(count, 0)),\n\n  size:\n    () =>\n    <T>(data: T[]) =>\n      data.length,\n\n  keys: () => Object.keys,\n  values: () => Object.values,\n\n  prod: () => (data: number[]) => reduce(data, (a, b) => a * b),\n\n  sum: () => (data: number[]) =>\n    isArray(data) ? data.reduce((a, b) => a + b, 0) : throwArrayExpected(),\n\n  average: () => (data: number[]) =>\n    isArray(data)\n      ? data.length > 0\n        ? data.reduce((a, b) => a + b) / data.length\n        : null\n      : throwArrayExpected(),\n\n  min: () => (data: number[]) => reduce(data, (a, b) => Math.min(a, b)),\n  max: () => (data: number[]) => reduce(data, (a, b) => Math.max(a, b)),\n\n  and: buildFunction((...data: unknown[]) => reduce(data, (a, b) => !!(a && b))),\n  or: buildFunction((...data: unknown[]) => reduce(data, (a, b) => !!(a || b))),\n  not: buildFunction((a: unknown) => !a),\n\n  exists: (queryGet: JSONQueryFunction) => {\n    const parentPath = queryGet.slice(1)\n    const key = parentPath.pop()\n    const getter = functions.get(...parentPath)\n\n    return (data: unknown) => {\n      const parent = getter(data)\n      return !!parent && Object.hasOwnProperty.call(parent, key)\n    }\n  },\n  if: (condition: JSONQuery, valueIfTrue: JSONQuery, valueIfFalse: JSONQuery) => {\n    const _condition = compile(condition)\n    const _valueIfTrue = compile(valueIfTrue)\n    const _valueIfFalse = compile(valueIfFalse)\n\n    return (data: unknown) => (truthy(_condition(data)) ? _valueIfTrue(data) : _valueIfFalse(data))\n  },\n  in: (value: JSONQuery, values: JSONQuery) => {\n    const getValue = compile(value)\n    const getValues = compile(values)\n\n    return (data: unknown) => {\n      const _value = getValue(data)\n      const _values = getValues(data) as unknown[]\n\n      return _values.findIndex((item) => isEqual(item, _value)) !== -1\n    }\n  },\n  'not in': (value: JSONQuery, values: JSONQuery) => {\n    const _in = functions.in(value, values)\n\n    return (data: unknown) => !_in(data)\n  },\n  regex: (path: JSONQuery, expression: string, options?: string) => {\n    const regex = new RegExp(expression, options)\n    const getter = compile(path)\n\n    return (data: unknown) => regex.test(getter(data) as string)\n  },\n\n  eq: buildFunction(isEqual),\n  gt: buildFunction(gt),\n  gte: buildFunction(gte),\n  lt: buildFunction(lt),\n  lte: buildFunction(lte),\n  ne: buildFunction((a, b) => !isEqual(a, b)),\n\n  add: buildFunction((a: number, b: number) => a + b),\n  subtract: buildFunction((a: number, b: number) => a - b),\n  multiply: buildFunction((a: number, b: number) => a * b),\n  divide: buildFunction((a: number, b: number) => a / b),\n  mod: buildFunction((a: number, b: number) => a % b),\n  pow: buildFunction((a: number, b: number) => a ** b),\n\n  abs: buildFunction(Math.abs),\n  round: buildFunction((value: number, digits = 0) => {\n    const num = Math.round(Number(`${value}e${digits}`))\n    return Number(`${num}e${-digits}`)\n  }),\n\n  number: buildFunction((text: string) => {\n    const num = Number(text)\n    return Number.isNaN(Number(text)) ? null : num\n  }),\n  string: buildFunction(String)\n}\n\nconst truthy = (x: unknown) => x !== null && x !== 0 && x !== false\n\nconst reduce = <T>(data: T[], callback: (previousValue: T, currentValue: T) => T): T => {\n  if (!isArray(data)) {\n    throwArrayExpected()\n  }\n\n  if (data.length === 0) {\n    return null\n  }\n\n  return data.reduce(callback)\n}\n\nconst throwArrayExpected = () => {\n  throwTypeError('Array expected')\n}\n\nexport const throwTypeError = (message: string) => {\n  throw new TypeError(message)\n}\n","import { functions, throwTypeError } from './functions'\nimport { isArray, isObject } from './is'\nimport type {\n  Fun,\n  FunctionBuildersMap,\n  JSONQuery,\n  JSONQueryCompileOptions,\n  JSONQueryFunction\n} from './types'\n\nconst functionsStack: FunctionBuildersMap[] = []\n\nexport function compile(query: JSONQuery, options?: JSONQueryCompileOptions): Fun {\n  functionsStack.unshift({ ...functions, ...functionsStack[0], ...options?.functions })\n\n  try {\n    const exec = isArray(query)\n      ? compileFunction(query as JSONQueryFunction, functionsStack[0]) // function\n      : isObject(query)\n        ? throwTypeError(\n            `Function notation [\"object\", {...}] expected but got ${JSON.stringify(query)}`\n          )\n        : () => query // primitive value (string, number, boolean, null)\n\n    // create a wrapper function which can attach a stack to the error\n    return (data) => {\n      try {\n        return exec(data)\n      } catch (err) {\n        // attach a stack to the error\n        err.jsonquery = [{ data, query }, ...(err.jsonquery ?? [])]\n\n        throw err\n      }\n    }\n  } finally {\n    functionsStack.shift()\n  }\n}\n\nfunction compileFunction(query: JSONQueryFunction, functions: FunctionBuildersMap) {\n  const [fnName, ...args] = query\n\n  const fnBuilder = functions[fnName]\n  if (!fnBuilder) {\n    throwTypeError(`Unknown function '${fnName}'`)\n  }\n\n  return fnBuilder(...args)\n}\n","import { isArray } from './is'\nimport type { CustomOperator, OperatorGroup } from './types'\n\n// operator precedence from highest to lowest\nexport const operators: OperatorGroup[] = [\n  { pow: '^' },\n  { multiply: '*', divide: '/', mod: '%' },\n  { add: '+', subtract: '-' },\n  { gt: '>', gte: '>=', lt: '<', lte: '<=', in: 'in', 'not in': 'not in' },\n  { eq: '==', ne: '!=' },\n  { and: 'and' },\n  { or: 'or' },\n  { pipe: '|' }\n]\n\nexport const varargOperators = ['|', 'and', 'or']\nexport const leftAssociativeOperators = ['|', 'and', 'or', '*', '/', '%', '+', '-']\n\nexport function extendOperators(operators: OperatorGroup[], customOperators: CustomOperator[]) {\n  // backward compatibility error with v4 where `operators` was an object\n  if (!isArray(customOperators)) {\n    throw new Error('Invalid custom operators')\n  }\n\n  return customOperators.reduce(extendOperator, operators)\n}\n\nfunction extendOperator(\n  operators: OperatorGroup[],\n  // @ts-expect-error Inside the function we will check whether at, below, and above are defined\n  { name, op, at, after, before }: CustomOperator\n): OperatorGroup[] {\n  if (at) {\n    return operators.map((group) => {\n      return Object.values(group).includes(at) ? { ...group, [name]: op } : group\n    })\n  }\n\n  const searchOp = after ?? before\n  const index = operators.findIndex((group) => Object.values(group).includes(searchOp))\n  if (index !== -1) {\n    return operators.toSpliced(index + (after ? 1 : 0), 0, { [name]: op })\n  }\n\n  throw new Error('Invalid custom operator')\n}\n","export const unquotedPropertyRegex = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nexport const startsWithUnquotedPropertyRegex = /^[a-zA-Z_$][a-zA-Z\\d_$]*/\nexport const startsWithStringRegex = /^\"(?:[^\"\\\\]|\\\\.)*\"/ // https://stackoverflow.com/a/249937/1262753\nexport const startsWithNumberRegex = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/ // https://stackoverflow.com/a/13340826/1262753\nexport const startsWithIntRegex = /^(0|[1-9][0-9]*)/\nexport const startsWithKeywordRegex = /^(true|false|null)/\nexport const startsWithWhitespaceRegex = /^[ \\n\\t\\r]+/\n","import { extendOperators, leftAssociativeOperators, operators, varargOperators } from './operators'\nimport {\n  startsWithIntRegex,\n  startsWithKeywordRegex,\n  startsWithNumberRegex,\n  startsWithStringRegex,\n  startsWithUnquotedPropertyRegex,\n  startsWithWhitespaceRegex\n} from './regexps'\nimport type { JSONQuery, JSONQueryParseOptions, OperatorGroup } from './types'\n\n/**\n * Parse a string containing a JSON Query into JSON.\n *\n * Example:\n *\n *     const textQuery = '.friends | filter(.city == \"new York\") | sort(.age) | pick(.name, .age)'\n *     const jsonQuery = parse(textQuery)\n *     // jsonQuery = [\n *     //    'pipe',\n *     //    ['get', 'friends'],\n *     //    ['filter', ['eq', ['get', 'city'], 'New York']],\n *     //    ['sort', ['get', 'age']],\n *     //    ['pick', ['get', 'name'], ['get', 'age']]\n *     //  ]\n */\nexport function parse(query: string, options?: JSONQueryParseOptions): JSONQuery {\n  const customOperators = options?.operators ?? []\n  const allOperators = extendOperators(operators, customOperators)\n  const allOperatorsMap = Object.assign({}, ...allOperators)\n  const allVarargOperators = varargOperators.concat(\n    customOperators.filter((op) => op.vararg).map((op) => op.op)\n  )\n  const allLeftAssociativeOperators = leftAssociativeOperators.concat(\n    customOperators.filter((op) => op.leftAssociative).map((op) => op.op)\n  )\n\n  const parseOperator = (precedenceLevel = allOperators.length - 1) => {\n    const currentOperators = allOperators[precedenceLevel]\n    if (!currentOperators) {\n      return parseParenthesis()\n    }\n\n    const leftParenthesis = query[i] === '('\n    let left = parseOperator(precedenceLevel - 1)\n\n    while (true) {\n      skipWhitespace()\n\n      const start = i\n      const name = parseOperatorName(currentOperators)\n      if (!name) {\n        break\n      }\n\n      const right = parseOperator(precedenceLevel - 1)\n\n      const childName = left[0]\n      const chained = name === childName && !leftParenthesis\n      if (chained && !allLeftAssociativeOperators.includes(allOperatorsMap[name])) {\n        i = start\n        break\n      }\n\n      left =\n        chained && allVarargOperators.includes(allOperatorsMap[name])\n          ? [...left, right]\n          : [name, left, right]\n    }\n\n    return left\n  }\n\n  const parseOperatorName = (currentOperators: OperatorGroup): string | undefined => {\n    // we sort the operators from longest to shortest, so we first handle \"<=\" and next \"<\"\n    const sortedOperatorNames = Object.keys(currentOperators).sort((a, b) => b.length - a.length)\n\n    for (const name of sortedOperatorNames) {\n      const op = currentOperators[name]\n      if (query.substring(i, i + op.length) === op) {\n        i += op.length\n\n        skipWhitespace()\n\n        return name\n      }\n    }\n\n    return undefined\n  }\n\n  const parseParenthesis = () => {\n    skipWhitespace()\n\n    if (query[i] === '(') {\n      i++\n      const inner = parseOperator()\n      eatChar(')')\n      return inner\n    }\n\n    return parseProperty()\n  }\n\n  const parseProperty = () => {\n    if (query[i] === '.') {\n      const props = []\n\n      while (query[i] === '.') {\n        i++\n\n        props.push(\n          parseString() ??\n            parseUnquotedString() ??\n            parseInteger() ??\n            throwSyntaxError('Property expected')\n        )\n      }\n\n      return ['get', ...props]\n    }\n\n    return parseFunction()\n  }\n\n  const parseFunction = () => {\n    const start = i\n    const name = parseUnquotedString()\n    skipWhitespace()\n    if (!name || query[i] !== '(') {\n      i = start\n      return parseObject()\n    }\n    i++\n\n    skipWhitespace()\n\n    const args = query[i] !== ')' ? [parseOperator()] : []\n    while (i < query.length && query[i] !== ')') {\n      skipWhitespace()\n      eatChar(',')\n      args.push(parseOperator())\n    }\n\n    eatChar(')')\n\n    return [name, ...args]\n  }\n\n  const parseObject = () => {\n    if (query[i] === '{') {\n      i++\n      skipWhitespace()\n\n      const object = {}\n      let first = true\n      while (i < query.length && query[i] !== '}') {\n        if (first) {\n          first = false\n        } else {\n          eatChar(',')\n          skipWhitespace()\n        }\n\n        const key =\n          parseString() ??\n          parseUnquotedString() ??\n          parseInteger() ??\n          throwSyntaxError('Key expected')\n\n        skipWhitespace()\n        eatChar(':')\n\n        object[key] = parseOperator()\n      }\n\n      eatChar('}')\n\n      return ['object', object]\n    }\n\n    return parseArray()\n  }\n\n  const parseArray = () => {\n    if (query[i] === '[') {\n      i++\n      skipWhitespace()\n\n      const array = []\n\n      let first = true\n      while (i < query.length && query[i] !== ']') {\n        if (first) {\n          first = false\n        } else {\n          eatChar(',')\n          skipWhitespace()\n        }\n\n        array.push(parseOperator())\n      }\n\n      eatChar(']')\n\n      return ['array', ...array]\n    }\n\n    return parseString() ?? parseNumber() ?? parseKeyword()\n  }\n\n  const parseString = () => parseRegex(startsWithStringRegex, JSON.parse)\n\n  const parseUnquotedString = () => parseRegex(startsWithUnquotedPropertyRegex, (text) => text)\n\n  const parseNumber = () => parseRegex(startsWithNumberRegex, JSON.parse)\n\n  const parseInteger = () => parseRegex(startsWithIntRegex, JSON.parse)\n\n  const parseKeyword = () => {\n    const keyword = parseRegex(startsWithKeywordRegex, JSON.parse)\n    if (keyword !== undefined) {\n      return keyword\n    }\n\n    // end of the parsing chain\n    throwSyntaxError('Value expected')\n  }\n\n  const parseEnd = () => {\n    skipWhitespace()\n\n    if (i < query.length) {\n      throwSyntaxError(`Unexpected part '${query.substring(i)}'`)\n    }\n  }\n\n  const parseRegex = <T = string>(regex: RegExp, callback: (match: string) => T): T | undefined => {\n    const match = query.substring(i).match(regex)\n    if (match) {\n      i += match[0].length\n      return callback(match[0])\n    }\n  }\n\n  const skipWhitespace = () => parseRegex(startsWithWhitespaceRegex, (text) => text)\n\n  const eatChar = (char: string) => {\n    if (query[i] !== char) {\n      throwSyntaxError(`Character '${char}' expected`)\n    }\n    i++\n  }\n\n  const throwSyntaxError = (message: string, pos = i) => {\n    throw new SyntaxError(`${message} (pos: ${pos})`)\n  }\n\n  let i = 0\n  const output = parseOperator()\n  parseEnd()\n\n  return output\n}\n","import { isArray } from './is'\nimport { extendOperators, leftAssociativeOperators, operators } from './operators'\nimport { unquotedPropertyRegex } from './regexps'\nimport type {\n  JSONPath,\n  JSONQuery,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryStringifyOptions\n} from './types'\n\nconst DEFAULT_MAX_LINE_LENGTH = 40\nconst DEFAULT_INDENTATION = '  '\n\n/**\n * Stringify a JSON Query into a readable, human friendly text syntax.\n *\n * Example:\n *\n *     const jsonQuery = [\n *         ['get', 'friends'],\n *         ['filter', ['eq', ['get', 'city'], 'New York']],\n *         ['sort', ['get', 'age']],\n *         ['pick', ['get', 'name'], ['get', 'age']]\n *       ]\n *     const textQuery = stringify(jsonQuery)\n *     // textQuery = '.friends | filter(.city == \"new York\") | sort(.age) | pick(.name, .age)'\n *\n * @param query The JSON Query to be stringified\n * @param {Object} [options] An object which can have the following options:\n *                 `maxLineLength` Optional maximum line length. When the query exceeds this maximum,\n *                                 It will be formatted over multiple lines. Default value: 40.\n *                 `indentation`   Optional indentation. Defaults to a string with two spaces: '  '.\n */\nexport const stringify = (query: JSONQuery, options?: JSONQueryStringifyOptions) => {\n  const space = options?.indentation ?? DEFAULT_INDENTATION\n  const customOperators = options?.operators ?? []\n  const allOperators = extendOperators(operators, customOperators)\n  const allOperatorsMap = Object.assign({}, ...allOperators)\n  const allLeftAssociativeOperators = leftAssociativeOperators.concat(\n    customOperators.filter((op) => op.leftAssociative).map((op) => op.op)\n  )\n\n  const _stringify = (query: JSONQuery, indent: string, parenthesis = false) =>\n    isArray(query)\n      ? stringifyFunction(query as JSONQueryFunction, indent, parenthesis)\n      : JSON.stringify(query) // value (string, number, boolean, null)\n\n  const stringifyFunction = (query: JSONQueryFunction, indent: string, parenthesis: boolean) => {\n    const [name, ...args] = query\n\n    if (name === 'get' && args.length > 0) {\n      return stringifyPath(args as JSONPath)\n    }\n\n    if (name === 'object') {\n      return stringifyObject(args[0] as JSONQueryObject, indent)\n    }\n\n    if (name === 'array') {\n      const argsStr = args.map((arg) => _stringify(arg, indent))\n      return join(\n        argsStr,\n        ['[', ', ', ']'],\n        [`[\\n${indent + space}`, `,\\n${indent + space}`, `\\n${indent}]`]\n      )\n    }\n\n    // operator like \".age >= 18\"\n    const op = allOperatorsMap[name]\n    if (op) {\n      const start = parenthesis ? '(' : ''\n      const end = parenthesis ? ')' : ''\n\n      const argsStr = args.map((arg, index) => {\n        const childName = arg?.[0]\n        const precedence = allOperators.findIndex((group) => name in group)\n        const childPrecedence = allOperators.findIndex((group) => childName in group)\n        const childParenthesis =\n          precedence < childPrecedence ||\n          (precedence === childPrecedence && index > 0) ||\n          (name === childName && !allLeftAssociativeOperators.includes(op))\n\n        return _stringify(arg, indent + space, childParenthesis)\n      })\n\n      return join(argsStr, [start, ` ${op} `, end], [start, `\\n${indent + space}${op} `, end])\n    }\n\n    // regular function like \"sort(.age)\"\n    const childIndent = args.length === 1 ? indent : indent + space\n    const argsStr = args.map((arg) => _stringify(arg, childIndent))\n    return join(\n      argsStr,\n      [`${name}(`, ', ', ')'],\n      args.length === 1\n        ? [`${name}(`, `,\\n${indent}`, ')']\n        : [`${name}(\\n${childIndent}`, `,\\n${childIndent}`, `\\n${indent})`]\n    )\n  }\n\n  const stringifyObject = (query: JSONQueryObject, indent: string) => {\n    const childIndent = indent + space\n    const entries = Object.entries(query).map(([key, value]) => {\n      return `${stringifyProperty(key)}: ${_stringify(value, childIndent)}`\n    })\n\n    return join(\n      entries,\n      ['{ ', ', ', ' }'],\n      [`{\\n${childIndent}`, `,\\n${childIndent}`, `\\n${indent}}`]\n    )\n  }\n\n  const stringifyPath = (path: JSONPath): string =>\n    path.map((prop) => `.${stringifyProperty(prop)}`).join('')\n\n  const stringifyProperty = (prop: string): string =>\n    unquotedPropertyRegex.test(prop) ? prop : JSON.stringify(prop)\n\n  type JoinDefinition = [start: string, separator: string, end: string]\n\n  const join = (\n    items: string[],\n    [compactStart, compactSeparator, compactEnd]: JoinDefinition,\n    [formatStart, formatSeparator, formatEnd]: JoinDefinition\n  ): string => {\n    const compactLength =\n      compactStart.length +\n      items.reduce((sum: number, item: string) => sum + item.length + compactSeparator.length, 0) -\n      compactSeparator.length +\n      compactEnd.length\n\n    return compactLength <= (options?.maxLineLength ?? DEFAULT_MAX_LINE_LENGTH)\n      ? compactStart + items.join(compactSeparator) + compactEnd\n      : formatStart + items.join(formatSeparator) + formatEnd\n  }\n\n  return _stringify(query, '')\n}\n","import { compile } from './compile'\nimport { isString } from './is'\nimport { parse } from './parse'\nimport type { JSONQuery, JSONQueryOptions } from './types'\n\nexport function jsonquery(\n  data: unknown,\n  query: string | JSONQuery,\n  options?: JSONQueryOptions\n): unknown {\n  return compile(isString(query) ? parse(query, options) : query, options)(data)\n}\n\nexport { compile } from './compile'\nexport { stringify } from './stringify'\nexport { parse } from './parse'\nexport { buildFunction } from './functions'\n\nexport type {\n  CustomOperator,\n  Fun,\n  FunctionBuilder,\n  FunctionBuildersMap,\n  JSONPath,\n  JSONProperty,\n  JSONQuery,\n  JSONQueryCompileOptions,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryOptions,\n  JSONQueryParseOptions,\n  JSONQueryPrimitive,\n  JSONQueryProperty,\n  JSONQueryPipe,\n  JSONQueryStringifyOptions\n} from './types'\n"],"names":["isArray","value","isObject","isString","isEqual","a","b","k","v","buildFunction","fn","args","compiledArgs","arg","compile","arg0","arg1","data","sortableTypes","otherTypes","gt","gte","lt","lte","functions","entries","_entries","entry","evaluator","query","getters","key","obj","getter","items","_items","item","path","prop","callback","_callback","output","updated","updatedKey","predicate","_predicate","truthy","direction","sign","compare","itemA","itemB","aIndex","bIndex","properties","_get","_pick","object","out","res","separator","text","start","end","resItem","count","reduce","throwArrayExpected","queryGet","parentPath","parent","condition","valueIfTrue","valueIfFalse","_condition","_valueIfTrue","_valueIfFalse","values","getValue","getValues","_value","_in","expression","options","regex","digits","num","x","throwTypeError","message","functionsStack","exec","compileFunction","err","fnName","fnBuilder","operators","varargOperators","leftAssociativeOperators","extendOperators","customOperators","extendOperator","name","op","at","after","before","group","searchOp","index","unquotedPropertyRegex","startsWithUnquotedPropertyRegex","startsWithStringRegex","startsWithNumberRegex","startsWithIntRegex","startsWithKeywordRegex","startsWithWhitespaceRegex","parse","allOperators","allOperatorsMap","allVarargOperators","allLeftAssociativeOperators","parseOperator","precedenceLevel","currentOperators","parseParenthesis","leftParenthesis","left","skipWhitespace","parseOperatorName","right","childName","chained","sortedOperatorNames","inner","eatChar","parseProperty","props","parseString","parseUnquotedString","parseInteger","throwSyntaxError","parseFunction","parseObject","first","parseArray","array","parseNumber","parseKeyword","parseRegex","keyword","parseEnd","match","char","pos","DEFAULT_MAX_LINE_LENGTH","DEFAULT_INDENTATION","stringify","space","_stringify","indent","parenthesis","stringifyFunction","stringifyPath","stringifyObject","argsStr","join","precedence","childPrecedence","childParenthesis","childIndent","stringifyProperty","compactStart","compactSeparator","compactEnd","formatStart","formatSeparator","formatEnd","sum","jsonquery"],"mappings":"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"}